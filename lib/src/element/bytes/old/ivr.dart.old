//  Copyright (c) 2016, 2017, 2018,
//  Poplar Hill Informatics and the American College of Radiology
//  All rights reserved.
//  Use of this source code is governed by the open source license
//  that can be found in the odw/LICENSE file.
//  Primary Author: Jim Philbin <jfphilbin@gmail.edu>
//  See the AUTHORS file for other contributors.
//
import 'package:core/src/dataset.dart';
import 'package:core/src/element/base.dart';
import 'package:core/src/element/bytes/bytes_element.dart';
import 'package:core/src/system.dart';
import 'package:core/src/tag.dart';
import 'package:core/src/utils/bytes.dart';
import 'package:core/src/utils/primitives.dart';
import 'package:core/src/value/uid.dart';
import 'package:core/src/vr.dart';

abstract class IvrElement<V> implements ByteElement<V> {
  @override
  IvrBytes get bytes;
  @override
  Iterable<V> get values;
  // **** End of Interface

  /// The [index] of the [Element] Definition for _this_. It is
  /// used to locate other values in the [Element] Definition.
  @override
  int get index => code;

  @override
  set values(Iterable<V> vList) =>
      unsupportedError('ByteElements are not settable.');

  /// Returns _true_ if _this_ and [other] are the same [IvrElement], and
  /// equal byte for byte.
  @override
  bool operator ==(Object other) =>
      (other is IvrElement) ? bytes == other.bytes : false;
  @override
  int get hashCode => bytes.hashCode;
  @override
  int get length => bytes.length;
  @override
  bool get isEvr => true;
  @override
  int get code => bytes.code;
  @override
  bool get isPublic => code.isEven;
  @override
  int get vrCode => bytes.vrCode;
  @override
  int get vrIndex => bytes.vrIndex;
  @override
  int get vfLengthOffset => bytes.vfLengthOffset;
  @override
  int get vfLengthField => bytes.vfLengthField;
  @override
  int get vfLength => bytes.vfLength;
  @override
  int get vfOffset => bytes.vfOffset;
  @override
  Bytes get vfBytes => bytes.vfBytes;
  @override
  Bytes get vBytes => bytes.vBytes;
  @override
  int get vfBytesLast => bytes.vfBytesLast;
  @override
  Tag get tag => Tag.lookupByCode(code, vrIndex);
  @override
  bool get isRetired => tag.isRetired;

  static Element makeFromCode(Dataset ds, int code, IvrBytes bytes) {
    final pCode = code & 0x1FFFF;
    if (pCode >= 0x10010 && pCode <= 0x100FF) return new PCivr(bytes);
    final vrIndex = bytes.vrIndex;
    final tag = lookupTagByCode(ds, code, kUNIndex);
    final tagVRIndex = tag.vrIndex;
    assert(tagVRIndex != kSQIndex);
    final ByteElement e = _ivrBDMakers[vrIndex](bytes, tagVRIndex);
    return (pCode >= 0x11000 && pCode <= 0x1FFFF) ? new PrivateData(e) : e;
  }

  static final List<Function> _ivrBDMakers = <Function>[
    _sqError, // stop reformat
    // Maybe Undefined Lengths
    OBivr.makeFromBytes, OWivr.makeFromBytes, UNivr.makeFromBytes,

    // IVR Long
    ODivr.makeFromBytes, OFivr.makeFromBytes, OLivr.makeFromBytes,
    UCivr.makeFromBytes, URivr.makeFromBytes, UTivr.makeFromBytes,

    // IVR Short
    AEivr.makeFromBytes, ASivr.makeFromBytes, ATivr.makeFromBytes,
    CSivr.makeFromBytes, DAivr.makeFromBytes, DSivr.makeFromBytes,
    DTivr.makeFromBytes, FDivr.makeFromBytes, FLivr.makeFromBytes,
    ISivr.makeFromBytes, LOivr.makeFromBytes, LTivr.makeFromBytes,
    PNivr.makeFromBytes, SHivr.makeFromBytes, SLivr.makeFromBytes,
    SSivr.makeFromBytes, STivr.makeFromBytes, TMivr.makeFromBytes,
    UIivr.makeFromBytes, ULivr.makeFromBytes, USivr.makeFromBytes,
  ];

  static Null _sqError(IvrBytes bytes, [int vrIndex]) =>
      invalidElementIndex(vrIndex);

  static Element makeFromBytesPixelData(int code, IvrBytes bytes,
      [int vfLengthField, TransferSyntax ts, VFFragments fragments]) {
    if (code != kPixelData)
      return invalidKey(code, 'Invalid Tag Code for PixelData');
    final vrIndex = bytes.vrIndex;
    switch (vrIndex) {
      case kOBIndex:
        return OBivrPixelData.makeFromBytes(code, bytes, ts, fragments);
      case kUNIndex:
        return UNivrPixelData.makeFromBytes(code, bytes, ts, fragments);
      case kOWIndex:
        return OWivrPixelData.makeFromBytes(code, bytes, ts, fragments);
      default:
        return VR.badIndex(vrIndex, null, null);
    }
  }

  /// Returns a new [SQivr], where [bytes] is [IvrBytes] for complete sequence.
  static SQivr makeFromBytesSequence(int code, Dataset parent,
          [Iterable<Item> items, IvrBytes bytes]) =>
      new SQivr(parent, items, bytes);
}

// **** IVR Float Elements (FL, FD, OD, OF)

class FLivr extends FL with TagMixin, IvrElement<double>, Float32Mixin {
  @override
  final IvrBytes bytes;

  FLivr(this.bytes);

  static FLivr makeFromBytes(Bytes bytes) => new FLivr(bytes);
}

class OFivr extends OF with TagMixin, IvrElement<double>, Float32Mixin {
  @override
  final IvrBytes bytes;

  OFivr(this.bytes);

  static OFivr makeFromBytes(Bytes bytes) => new OFivr(bytes);
}

// **** IVR 64-Bit Float Elements (OD, OF)

class FDivr extends FL with TagMixin, IvrElement<double>, Float64Mixin {
  @override
  final IvrBytes bytes;

  FDivr(this.bytes);

  static FDivr makeFromBytes(Bytes bytes) => new FDivr(bytes);
}

class ODivr extends OD with TagMixin, IvrElement<double>, Float64Mixin {
  @override
  final IvrBytes bytes;

  ODivr(this.bytes);

  static ODivr makeFromBytes(Bytes bytes) => new ODivr(bytes);
}

// **** Integer Elements
// **** 8-bit Integer Elements (OB, UN)

class OBivr extends OB with TagMixin, IvrElement<int>, Uint8Mixin {
  @override
  final IvrBytes bytes;

  OBivr(this.bytes);

  static OBivr makeFromBytes(Bytes bytes) => new OBivr(bytes);
}

class OBivrPixelData extends OBPixelData
    with TagMixin, IvrElement<int>, Uint8Mixin {
  @override
  final IvrBytes bytes;
  @override
  TransferSyntax ts;
  @override
  VFFragments fragments;

  OBivrPixelData(this.bytes, [this.ts, this.fragments]);

  static OBivrPixelData makeFromBytes(int code, IvrBytes bytes,
          [TransferSyntax ts, VFFragments fragments]) =>
      new OBivrPixelData(bytes, ts, fragments);
}

class UNivr extends UN with TagMixin, IvrElement<int>, Uint8Mixin {
  @override
  final IvrBytes bytes;

  UNivr(this.bytes);

  static UNivr makeFromBytes(Bytes bytes) => new UNivr(bytes);
}

class UNivrPixelData extends UNPixelData
    with TagMixin, IvrElement<int>, Uint8Mixin {
  @override
  final IvrBytes bytes;
  @override
  TransferSyntax ts;
  @override
  VFFragments fragments;

  UNivrPixelData(this.bytes, [this.ts, this.fragments]);

  static UNivrPixelData makeFromBytes(int code, IvrBytes bytes,
          [TransferSyntax ts, VFFragments fragments]) =>
      new UNivrPixelData(bytes, ts, fragments);
}

// **** 16-bit Integer Elements (SS, US, OW)

class SSivr extends SS with TagMixin, IvrElement<int>, Int16Mixin {
  @override
  final IvrBytes bytes;

  SSivr(this.bytes);

  static SSivr makeFromBytes(Bytes bytes) => new SSivr(bytes);
}

class USivr extends US with TagMixin, IvrElement<int>, Uint16Mixin {
  @override
  final IvrBytes bytes;

  USivr(this.bytes);

  static USivr makeFromBytes(Bytes bytes) => new USivr(bytes);
}

class OWivr extends OW with TagMixin, IvrElement<int>, Uint16Mixin {
  @override
  final IvrBytes bytes;

  OWivr(this.bytes);

  static OWivr makeFromBytes(Bytes bytes) => new OWivr(bytes);
}

class OWivrPixelData extends OWPixelData
    with TagMixin, IvrElement<int>, Uint16Mixin {
  @override
  final IvrBytes bytes;
  @override
  TransferSyntax ts;
  @override
  VFFragments fragments;

  OWivrPixelData(this.bytes, [this.ts, this.fragments]);

  static OWivrPixelData makeFromBytes(int code, IvrBytes bytes,
          [TransferSyntax ts, VFFragments fragments]) =>
      new OWivrPixelData(bytes, ts, fragments);
}

// **** 32-bit integer Elements (AT, SL, UL, GL)

/// Attribute (Element) Code (AT)
class ATivr extends AT with TagMixin, IvrElement<int>, Uint32Mixin {
  @override
  final IvrBytes bytes;

  ATivr(this.bytes);

  static ATivr makeFromBytes(Bytes bytes) => new ATivr(bytes);
}

/// Other Long (OL)
class OLivr extends OL with TagMixin, IvrElement<int>, Uint32Mixin {
  @override
  final IvrBytes bytes;

  OLivr(this.bytes);

  static OLivr makeFromBytes(Bytes bytes) => new OLivr(bytes);
}

/// Signed Long (SL)
class SLivr extends SL with TagMixin, IvrElement<int>, Int32Mixin {
  @override
  final IvrBytes bytes;

  SLivr(this.bytes);

  static SLivr makeFromBytes(Bytes bytes) => new SLivr(bytes);
}

/// Unsigned Long (UL)
class ULivr extends UL with TagMixin, IvrElement<int>, Uint32Mixin {
  @override
  final IvrBytes bytes;

  ULivr(this.bytes);

  static Element<int> makeFromBytes(IvrBytes bytes) =>
      // If the code is (gggg,0000) create a Group Length element
      (bytes.getUint16(2) == 0) ? new GLivr(bytes) : new ULivr(bytes);
}

/// Group Length (GL)
class GLivr extends GL with TagMixin, IvrElement<int>, Uint32Mixin {
  @override
  final IvrBytes bytes;

  GLivr(this.bytes);

  static const String kVRKeyword = 'GL';
  static const String kVRName = 'Group Length';

  static GLivr makeFromBytes(Bytes bytes) => new GLivr(bytes);
}

// **** Acsii Classes

class AEivr extends AE
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  AEivr(this.bytes);

  static AEivr makeFromBytes(Bytes bytes) => new AEivr(bytes);
}

class ASivr extends AS
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  ASivr(this.bytes);

  static ASivr makeFromBytes(IvrBytes bytes) {
    final length = bytes.length;
    if (length != 12 && length != 8)
      log.warn('Invalid Age (AS) "${bytes.getUtf8()}"');
    return new ASivr(bytes);
  }
}

class CSivr extends CS
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  CSivr(this.bytes);

  static CSivr makeFromBytes(Bytes bytes) => new CSivr(bytes);
}

class DAivr extends DA
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  DAivr(this.bytes);

  static DAivr makeFromBytes(IvrBytes bytes) {
    final length = bytes.length;
    if (length != 16 && length != 8)
      log.debug('Invalid Date (DA) "${bytes.getUtf8()}"');
    return new DAivr(bytes);
  }
}

class DSivr extends DS
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  DSivr(this.bytes);

  static DSivr makeFromBytes(Bytes bytes) => new DSivr(bytes);
}

class DTivr extends DT
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  DTivr(this.bytes);

  static DTivr makeFromBytes(Bytes bytes) => new DTivr(bytes);
}

class ISivr extends IS
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  ISivr(this.bytes);

  static ISivr makeFromBytes(Bytes bytes) => new ISivr(bytes);
}

class UIivr extends UI
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  UIivr(this.bytes);

  @override
  Iterable<Uid> get uids => Uid.parseList(bytes.getAsciiList());

  static UIivr makeFromBytes(Bytes bytes) => new UIivr(bytes);
}

class TMivr extends TM
    with TagMixin, IvrElement<String>, StringMixin, AsciiMixin {
  @override
  final IvrBytes bytes;

  TMivr(this.bytes);

  static TMivr makeFromBytes(Bytes bytes) => new TMivr(bytes);
}

// **** UTF8 Classes

class LOivr extends LO
    with TagMixin, IvrElement<String>, StringMixin, Utf8Mixin {
  @override
  final IvrBytes bytes;

  LOivr(this.bytes);

  static LOivr makeFromBytes(Bytes bytes) {
    final group = bytes.getUint16(0);
    final elt = bytes.getUint16(2);
    return (group.isOdd && elt >= 0x10 && elt <= 0xFF)
        ? new PCivr(bytes)
        : new LOivr(bytes);
  }
}

class PCivr extends PC
    with TagMixin, IvrElement<String>, StringMixin, Utf8Mixin {
  @override
  final IvrBytes bytes;

  PCivr(this.bytes);

  @override
  String get token => vfString;

  static PCivr makeFromBytes(Bytes bytes) => new PCivr(bytes);

  // Urgent: remove when working
/*
  static PCivr makeEmptyPrivateCreator(int pdTag, int vrIndex) {
    final group = Tag.privateGroup(pdTag);
    final sgNumber = (pdTag & 0xFFFF) >> 8;
    final bytes = new Bytes(8)
      ..setUint16(0, group)
      ..setUint16(0, sgNumber)
      ..setUint16(4, kLOIndex)
      //     ..setUint8(5, kO)
      ..setUint16(6, 0);
    return new PCivr(bytes);
  }
*/

}

class PNivr extends PN
    with TagMixin, IvrElement<String>, StringMixin, Utf8Mixin {
  @override
  final IvrBytes bytes;

  PNivr(this.bytes);

  static PNivr makeFromBytes(Bytes bytes) => new PNivr(bytes);
}

class SHivr extends SH
    with TagMixin, IvrElement<String>, StringMixin, Utf8Mixin {
  @override
  final IvrBytes bytes;

  SHivr(this.bytes);

  static SHivr makeFromBytes(Bytes bytes) => new SHivr(bytes);
}

class UCivr extends UC
    with TagMixin, IvrElement<String>, StringMixin, Utf8Mixin {
  @override
  final IvrBytes bytes;

  UCivr(this.bytes);

  static UCivr makeFromBytes(Bytes bytes) => new UCivr(bytes);
}

// **** Text Classes

class LTivr extends LT with TagMixin, IvrElement<String>, TextMixin {
  @override
  final IvrBytes bytes;

  LTivr(this.bytes);

  static LTivr makeFromBytes(Bytes bytes) => new LTivr(bytes);
}

class STivr extends ST with TagMixin, IvrElement<String>, TextMixin {
  @override
  final IvrBytes bytes;

  STivr(this.bytes);

  static STivr makeFromBytes(Bytes bytes) => new STivr(bytes);
}

class URivr extends UR with TagMixin, IvrElement<String>, TextMixin {
  @override
  final IvrBytes bytes;

  URivr(this.bytes);

  static URivr makeFromBytes(Bytes bytes) => new URivr(bytes);
}

class UTivr extends UT with TagMixin, IvrElement<String>, TextMixin {
  @override
  final IvrBytes bytes;

  UTivr(this.bytes);

  static UTivr makeFromBytes(Bytes bytes) => new UTivr(bytes);
}

// **** Sequence Classes
class SQivr extends SQ with TagMixin, IvrElement<Item> {
  @override
  final Dataset parent;
  @override
  Iterable<Item> values;
  @override
  final IvrBytes bytes;

  SQivr(this.parent, this.values, this.bytes);

  @override
  int get valuesLength => values.length;

  static SQivr makeFromBytes(Dataset parent,
          [SQ sequence, Iterable<Item> values, IvrBytes bytes]) =>
      new SQivr(parent, values, bytes);
}
