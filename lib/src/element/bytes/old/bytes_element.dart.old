//  Copyright (c) 2016, 2017, 2018,
//  Poplar Hill Informatics and the American College of Radiology
//  All rights reserved.
//  Use of this source code is governed by the open source license
//  that can be found in the odw/LICENSE file.
//  Primary Author: Jim Philbin <jfphilbin@gmail.edu>
//  See the AUTHORS file for other contributors.
//
import 'dart:typed_data';

import 'package:core/src/dataset/base.dart';
import 'package:core/src/element/base.dart';
import 'package:core/src/element/bytes/evr.dart';
import 'package:core/src/element/bytes/ivr.dart';
import 'package:core/src/tag.dart';
import 'package:core/src/utils/bytes.dart';
import 'package:core/src/utils/primitives.dart';

// TODO: move documentation from EVR/IVR
abstract class ByteElement<V> extends Element<V> {
  /// The [Bytes] containing this Element.
  DicomBytes get bytes;

  /// Returns _true_ if this Element is encoded as Explicit VR Little Endian;
  /// otherwise, it is encoded as Implicit VR Little Endian, which is retired.
  bool get isEvr;
  @override
  int get code;
  @override
  int get vrCode;
  @override
  int get vrIndex;

  /// Returns the Value Field Length field offset from the beginning of bytes.
  int get vfLengthOffset;

  /// Returns the Value Field offset from the beginning of bytes.
  int get vfOffset;

  @override
  int get vfLength;

  /// The Value Field [Bytes] of this Element with padding character, if any.
  @override
  Bytes get vfBytes;

  int get vfBytesLast => bytes.getUint8(vfLength - 1);

  int get vLength;

  /// The Value Field [Bytes] of this Element without any padding character.
  @override
  Bytes get vBytes;

  // **** End Interface ****

  @override
  Tag get tag => Tag.lookupByCode(code, vrIndex);

  static Element make<V>(Dataset ds, int code, Bytes bytes,
      {bool isEvr = true}) =>
     (isEvr)
        ? EvrElement.makeFromCode(ds, code, bytes)
        : IvrElement.makeFromCode(ds, code, bytes);
}

/*
class PrivateData extends ByteElement<Object> with MetaElementMixin {
  @override
  final ByteElement e;

  PrivateData(this.e);

  @override
  DicomBytes get bytes => e.bytes;
  @override
  bool get isEvr => e.isEvr;
  @override
  int get vfLengthOffset => e.vfLengthOffset;
  @override
  int get vfOffset => e.vfOffset;
  @override
  Bytes get vfBytes => e.vfBytes;
  @override
  int get vfBytesLast => e.vfBytesLast;
  @override
  Bytes get vBytes => e.vBytes;
  @override
  int get valuesLength => e.valuesLength;
  @override
  Iterable get values => e.values;
  @override
  set values(Iterable vList) => e.values = vList;

  static PrivateData make<V>(Dataset ds, int code, Bytes bytes,
      {bool isEvr = true}) {
    assert(bytes.length.isEven);
    final e = ByteElement.make<V>(ds, code, bytes, isEvr: true);
    return new PrivateData(e);
  }
}
*/

/// 16-bit signed integer Elements (SS)
abstract class Int16Mixin {
  int get vfLengthField;
  Bytes get vfBytes;

  int get valuesLength => _fixedSizeLength(vfLengthField, Int16.kSizeInBytes);

  Iterable<int> get values => vfBytes.asInt16List();
}

/// 32-bit signed integer Elements (SL)
abstract class Int32Mixin {
  int get vfLengthField;
  Bytes get vfBytes;

  int get valuesLength => _fixedSizeLength(vfLengthField, Int32.kSizeInBytes);

  Iterable<int> get values => vfBytes.asInt32List();
}

/// 8-bit Integer Elements (OB, UN)
abstract class Uint8Mixin {
  int get vfLengthField;
  Bytes get vfBytes;
  int get vfBytesLast;

  bool get hasPadding => vfBytesLast == 0;
  bool get hasValidPadding => hasPadding;
  int get paddingCharacter => vfBytesLast;

  int get valuesLength => _fixedSizeLength(vfLengthField, Uint8.kSizeInBytes);

  Iterable<int> get values => vfBytes.asUint8List();
}


/// 16-bit unsigned integer Elements (US, OW)
abstract class Uint16Mixin {
  int get vfLengthField;
  Bytes get vfBytes;

  int get valuesLength => _fixedSizeLength(vfLengthField, Uint16.kSizeInBytes);

  Iterable<int> get values => vfBytes.asUint16List();
}


/// 32-bit unsigned integer Elements (AT, UL, GL, OL)
abstract class Uint32Mixin {
  int get vfLengthField;
  Bytes get vfBytes;

  int get valuesLength => _fixedSizeLength(vfLengthField, Uint32.kSizeInBytes);

  Iterable<int> get values => vfBytes.asUint32List();
}

/// 32-bit Float Elements (FL, OF)
abstract class Float32Mixin {
  int get vfLengthField;
  Bytes get vfBytes;

  int get valuesLength => _fixedSizeLength(vfLengthField, Float32.kSizeInBytes);

  Float32List get values => vfBytes.asFloat32List();
}

/// Long Float Elements (FD, OD)
abstract class Float64Mixin {
  int get vfLengthField;
  Bytes get vfBytes;
  int get vfOffset;

  int get valuesLength => _fixedSizeLength(vfLengthField, Float64.kSizeInBytes);

  Float64List get values => vfBytes.asFloat64List();
}

int _fixedSizeLength(int vfLengthField, int sizeInBytes) {
  final vlf = vfLengthField;
  final length = vlf ~/ sizeInBytes;
  assert(vlf >= 0 && vlf.isEven, 'vfLengthField: $vlf');
  assert(vlf % sizeInBytes == 0, 'vflf: $vlf sizeInBytes $sizeInBytes');
  return length;
}



/*
/// All [String] Elements
abstract class ByteStringMixin {
  Bytes get vfBytes;

  int get valuesLength {
    if (vfBytes.isEmpty) return 0;
    var count = 1;
    for (var i = 0; i < vfBytes.length; i++)
      if (vfBytes[i] == kBackslash) count++;
    return count;
  }
}
*/

/// [String] [Element]s that only have ASCII values.
abstract class StringMixin {
  int get vfLength;
  Bytes get vfBytes;
  Bytes get vBytes;
  int get vfBytesLast;
  String get vfString;

  /// Returns _true if [vfBytes] ends with a padding character.
  bool get hasPadding => vfLength.isEven && vfBytesLast == 0;

  /// Returns _true if the padding character, if any, is valid for _this_.
  bool get hasValidPadding => hasPadding && (padChar == kSpace);

  /// If [vfLength] is not empty and [vfLength] is not equal to zero,
  /// returns the last Uint8 element in [vfBytes]; otherwise, returns null;
  int get padChar => ( vfLength != 0 && vfLength.isEven) ? vfBytesLast : null;

  /// Returns the number of values in [vfBytes].
  int get valuesLength => _stringValuesLength(vfBytes);

  Iterable<String> get values => vfString.split('\\');
}

/// [String] [Element]s that only have ASCII values.
abstract class AsciiMixin {
  Bytes get vBytes;

  bool allowInvalid = true;

  String get vfString => vBytes.getAscii(allowInvalid: allowInvalid);

  Iterable<String> get values => vfString.split('\\');
}

/// [String] [Element]s that may have UTF-8 values.
abstract class Utf8Mixin {
  Bytes get vBytes;

  int get valuesLength => _stringValuesLength(vBytes);

  bool allowMalformed = true;

  String get vfString => vBytes.getUtf8(allowMalformed: allowMalformed);
}

/// Text ([String]) [Element]s that may only have 1 UTF-8 value.
abstract class TextMixin {
  Bytes get vBytes;

  int get valuesLength => 1;

  bool allowMalformed = true;

  String get vfString => vBytes.getUtf8(allowMalformed: allowMalformed);
  String get value => vfString;
  Iterable<String> get values => [vfString];
}

int _stringValuesLength(Bytes vfBytes) {
  if (vfBytes.isEmpty) return 0;
  var count = 1;
  for (var i = 0; i < vfBytes.length; i++)
    if (vfBytes[i] == kBackslash) count++;
  return count;
}